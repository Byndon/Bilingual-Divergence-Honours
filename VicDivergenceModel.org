#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: VicDivergenceModel
#+date: <2020-09-13 Sun>
#+author: Callan Bindon
#+email: 22242833@student.uwa.edu.au
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 26.3 (Org mode 9.3.6)
#+PROPERTIES: header-args:python :session *Py* :noweb yes :tangle yes :eval never-export


* Project Goals and Overview
#+begin_quote
/What types of multilingual speaker interaction can help to explain the synchronic patterns of lexical difference in Victorian Aboriginal Languages?/
#+end_quote

In this study, I will be producing various models of lexical change in an attempt to find a model which has the best fit for the synchronic lexical patterns observed in Victorian Aboriginal languages. The model will include a variety of parameters, including the possible effects of the  \textsc{anti-doppel bias}, a production bias against word forms common to a bilingual's languages, which has not been previously considered. 

This research question is based on Historical linguistic principles of applying known synchronic processes over time in an attempt to find out about the linguistic past of languages and their communities of speakers.

* Emacs Set-Up :noexport:
#+begin_src emacs-lisp :results none
  (setq-local org-babel-default-header-args:Python '((:session . "*PyABM*")))
  org-babel-default-header-args:Python
#+end_src
* The Agent/Model Setup
#+NAME:setup
#+begin_src python :results none
  from mesa import Agent, Model
  import random, math, matplotlib, numpy
  import multilevel_mesa as mlm
#+end_src

The SpeakerSubAgent is a class which represents the make up of the language community. This class is the basis of the Language input part of the model described in Ellison and Miceli (2017). Each individual speaker is represented as having a repertoire of languages, a language mode, and a language monitoring level. When creating a language community (an agent) the language repertoire can be determined by the adjacent language communities, or set manually. The language mode and monitor can be set manually, randomly, or determined by the ratios of other speakers in the comunity. 
#+NAME:SpeakerSubAgent
#+begin_src python :results output
  class SpeakerSubAgent:
      def __init__(self, community_language, mode=False, monitoring=False):
          self.language_repertoire = []
          self.mode = 0
          self.monitoring = 0
          self.language_repertoire_add(community_language)

      def language_repertoire_add(self, language):
          self.language_repertoire.append(language)

      def language_mode(self, mode):
          if mode is False:
              self.mode = random.uniform(0,1)
          elif mode is True:
              #determine mode based on others in the community.
              pass
          else:
              if(0 < mode and mode < 1):
                  self.mode = mode

      def monitoring_level(self):
          if monitoring is False:
              self.monitoring = random.uniform(0,1)
          if monitoring is True:
              #determine monitoring based on others in the community
              pass
          else:
              if(0 < mode and mode < 1):
                  self.monitoring = monitoring
#+end_src
The Agent 
#+NAME:CommunityAgentClass
#+begin_src python
  class CommunityAgent(Agent):
      def __init__(self, name, model):
          super().__init__(name, model)
          self.name = name

      def step(self):
          print("{} activated".format(self.name))
          # Whatever else the agent does when activated


#+end_src

#+NAME:NetworkedCommunities
#+begin_src python
  class VicModel(Model):
      pass
#+end_src

The Language class is the class representative of the languages of the communities. It is a dictionary. The Keys are the Meanings, and the values are lists of forms. As of yet, I don't know if the forms should be full forms or simply representations. It doesn't really matter for this application as far as I know.
#+NAME:LanguageClass
#+begin_src python
  class Language:
      def __init__(self):
          self.formMeaningDict = {}
#+end_src

#+NAME:Model&Data
#+begin_src python

#+end_src
