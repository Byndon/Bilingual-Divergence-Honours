:header:
#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: VicDivergenceModel
#+date: <2020-10-26 Mon>
#+author: Callan Bindon
#+email: 22242833@student.uwa.edu.au
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 26.3 (Org mode 9.4)
:END:
* Project Goals and Overview
#+begin_quote
/What types of multilingual speaker interaction can help to explain the synchronic patterns of lexical difference in Victorian Aboriginal Languages?/
#+end_quote

In this study, I will be producing various models of lexical change in an attempt to find a model which has the best fit for the synchronic lexical patterns observed in Victorian Aboriginal languages. The model will include a variety of parameters, including the possible effects of the  \textsc{anti-doppel bias}, a production bias against word forms common to a bilingual's languages, which has not been previously considered. 

This research question is based on Historical linguistic principles of applying known synchronic processes over time in an attempt to find out about the linguistic past of languages and their communities of speakers.

* Model Setup
#+PROPERTIES: header-args:python :session *PyABM* :tangle model.py :eval never-export
#+begin_src python :tangle model.py
  from mesa import Agent, Model
  import multilevel_mesa as mlm
  import pandas
  import csv
#+end_src
** The Language Class
The language class is a class to represent the set of languages in this study. Languages are represented by dictionary objects where the Keys are Meanings /s/, and the Values are a list of tuples of form /f/ and the relative frequency of that form. A single meaning can be mapped to many synonymous forms, and as such, the tuples are inside a list.
#+BEGIN_CENTER
/Therefore/ Meaning : (form1,%), (from2,%), etc.
#+END_CENTER
The Relative frequency of the form can be determined randomly; with the generation of a random number for each of the froms, which will be divided by the total number of uses for the meaning. Thus:

#+begin_src python :tangle model.py
  class language:
      def __init__(self):
          self.formMeaningDict = {}

      def add_from_file(filename):
          # this method will be able to take a file, formatted as CSV
          # and turn it into a dictionary with Meaning Keys, and
          # a list of tuples with Form and Relative frequency
          # relative frequency should be a parameter, but
          # can also be randomly determined.
          pass
#+end_src

** Agent
The Agent in this model represents a Speaker of a set of Languages. They have language mode and language monitoring parameters and a repertoire of languages which they can use. At Each step of the model simulation, Agents will choose a  Meaning /s/, and attempt to produce a target from /t/, based on the language they are aiming to speak in. The target language will be the language that is assigned to the community of which they are a member.
#+begin_src python :tangle model.py
  class SpeakerAgent(Agent):
      def __init__(self, name, model):
          super().__init__(name, model)
          self.name = name
          self.language_repertoire = []
          self.mode = 0
          self.monitoring = 0

      def language_repertoire_add(self, language):
          self.language_repertoire.append(language)

      def language_mode(self, mode):
          if mode is False:
              self.mode = self.random.uniform(0, 1)
          elif mode is True:
              # determine mode based on others in the community.
              pass
          else:
              if(0 < mode and mode < 1):
                  self.mode = mode

      def monitoring_level(self, monitoring):
          if monitoring is False:
              self.monitoring = random.uniform(0,1)
          if monitoring is True:
              # determine monitoring based on others in the community
              pass
          else:
              if(0 < monitoring and monitoring < 1):
                  self.monitoring = monitoring

      def step(self):
          # implement step here.
          # From community/group language, choose
          #     a meaning at random.
          # Attempt to produce the target form
          #     using the Pc Model
          # Whichever form was produced, add 1 to the usage of it.
          #     (if not in target language do nothing?)
          #     (It forms a tally of words, we can produce a percentage)
          pass

#+end_src

** Model
#+begin_src python :tangle model.py
  class DivergenceModel(Model):
      def __init__(self):
          super().__init__()

      def step(self):
          self.schedule.step()
#+end_src
* Server/Visualisation Setup
#+PROPERTIES: header-args:python :session *PyABM* :noweb yes :tangle server.py :eval never-export
* Run Script Setup
#+PROPERTIES: header-args:python :session *PyABM* :noweb yes :tangle run.py :eval never-export
